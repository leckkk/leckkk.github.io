{"meta":{"title":"Leck的吹逼现场","subtitle":"","description":"","author":"leck","url":"http://leckkk.github.io","root":"/"},"pages":[{"title":"友情链接","date":"2021-11-08T11:41:53.213Z","updated":"2021-11-08T11:41:53.213Z","comments":true,"path":"links/index.html","permalink":"http://leckkk.github.io/links/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-11-08T11:45:35.081Z","updated":"2021-11-08T11:45:35.081Z","comments":false,"path":"categories/index.html","permalink":"http://leckkk.github.io/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2021-11-08T11:41:25.985Z","updated":"2021-11-08T11:41:25.985Z","comments":false,"path":"repository/index.html","permalink":"http://leckkk.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-11-08T11:45:47.441Z","updated":"2021-11-08T11:45:47.441Z","comments":false,"path":"tags/index.html","permalink":"http://leckkk.github.io/tags/index.html","excerpt":"","text":""},{"title":"书单","date":"2021-11-08T11:42:17.382Z","updated":"2021-11-08T11:42:17.382Z","comments":false,"path":"books/index.html","permalink":"http://leckkk.github.io/books/index.html","excerpt":"","text":""},{"title":"关于","date":"2021-11-08T11:45:54.840Z","updated":"2021-11-08T11:45:54.840Z","comments":false,"path":"about/index.html","permalink":"http://leckkk.github.io/about/index.html","excerpt":"","text":"个人详细介绍"}],"posts":[{"title":"Hello World","slug":"hello-world","date":"2021-03-16T03:32:39.417Z","updated":"2021-03-16T04:53:02.237Z","comments":true,"path":"2021/03/16/hello-world/","link":"","permalink":"http://leckkk.github.io/2021/03/16/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"计算机网络","slug":"计算机网络","date":"2020-12-19T07:36:16.651Z","updated":"2021-03-16T04:55:55.565Z","comments":true,"path":"2020/12/19/计算机网络/","link":"","permalink":"http://leckkk.github.io/2020/12/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/","excerpt":"","text":"[toc] 计算机网络体系结构 层数 OSI7层 层数 TCP/IP的四层协议 层数 五层协议 7 应用层 6 表示层 5 会话层 4 应用层（telnet/ftp/http/smtp） 5 应用层 4 运输层 3 运输层（tcp/udp） 4 运输层 3 网络层 2 网络层（ip/icmp/igmp） 3 网络层 2 数据链路层 1 链路层（以太网驱动程序） 2 数据链路层 1 物理层 1 物理层 运输层TCP与UDP区别 基于连接和无连接 对系统资源要求一个多一个少 TCP保证数据正确性，UDP可能丢包，TCP能保证数据顺序，UDP不保证 TCP面向字节流，UDP面向报文 TCP首部20字节，UDP8字节 TCP一条只能点对点，UDP可以一对一、一对多、多对一、多对多 UDP没有拥塞控制 使用udp和tcp的各种应用和应用层协议 应用 应用层协议 运输层协议 名字转换 DNS UDP 文件传送 TFTP（简单文件传送协议） UDP 路由选择协议 RIP（路由信息协议） UDP IP地址配置 DHCP UDP 网络管理 SNMP（简单网络管理协议） UDP 远程文件服务器 NFS（网络文件系统） UDP 多播 IGMP（网际组管理协议） UDP 电子邮件 SMTP（简单邮件传送协议） TCP 远程终端接入 TELNET（远程终端协议） TCP 万维网 HTTP TCP 文件传送 FTP TCP TCPTCP报文结构 TCP三次握手URG(urgent紧急) ACK(Acknowledgement 确认ACK) 1位 PSH(push传送) 1为 RST(reset重置) 1位 SYN(synchronous建立联机) 1位 FIN(finish结束) 1位 Sequence number(顺序号码) 4字节 Acknowledge number(确认号码) 4字节 第一次握手：主机 A 发送位码为 syn＝1，随机产生 seq number=1234567 的数据包到服务器，主机 B 由 SYN=1 知道，A 要求建立联机； SYN=1,seq=x 第二次握手：主机 B 收到请求后要确认联机信息，向 A 发送 ack number=(主机 A 的 seq+1)，syn=1，ack=1，随机产生 seq=7654321 的包； SYN=1,ACK=1,ack=x+1,seq=y 第三次握手：主机 A 收到后检查 ack number 是否正确，即第一次发送的 seq number+1，以及位码 ack 是否为 1，若正确，主机 A 会再发送 ack number=(主机 B 的 seq+1)，ack=1，主机 B 收到后确认 seq 值与 ack=1 则连接建立成功。 ACK=1,ack=y+1,seq=x+1 TCP四次挥手 UDPUDP报文结构 KCPKCP是一个快速可靠协议，能以比 TCP浪费10%-20%的带宽的代价，换取平均延迟降低 30%-40%，且最大延迟降低三倍的传输效果。纯算法实现，并不负责底层协议（如UDP）的收发，需要使用者自己定义下层数据包的发送方式，以 callback的方式提供给 KCP。 连时钟都需要外部传递进来，内部不会有任何一次系统调用。 mKCPvmess魔改的kcp协议 应用层HTTP ([腾讯云开发者手册][https://cloud.tencent.com/developer/doc/1117])超文本传输协议（英语：HyperText Transfer Protocol，缩写：HTTP）是一种用于分布式、协作式和超媒体信息系统的应用层协议。 HTTP通信通常通过TCP/IP连接进行。默认端口为TCP 80，但也可以使用其他端口。这并不排除在Internet或其他网络上的任何其他协议之上实现HTTP。HTTP只假定传输可靠；可以使用任何提供这种保证的协议。 http请求包括:请求行、请求头、请求体 http响应包括:响应行、响应头、响应体 HTTP工作原理HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。 以下是 HTTP 请求/响应的步骤： 1. 客户端连接到Web服务器一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。 2. 发送HTTP请求通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。 3. 服务器接受请求并返回HTTP响应Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。 4. 释放连接TCP连接若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求; 5. 客户端浏览器解析HTML内容客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。 例如：在浏览器地址栏键入URL，按下回车之后会经历以下流程： 浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址; 解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立TCP连接; 浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器; 服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器; 释放 TCP连接; 浏览器将该 html 文本并显示内容; 请求行POST /chapter17/user.html HTTP/1.1 请求方式 资源路径 协议/版本 请求方法（八种） GET 向指定的资源发出“显示”请求。使用GET方法应该只用在读取资料，而不应当被用于产生“副作用”的操作中，例如在网络应用程序中。其中一个原因是GET可能会被网络爬虫等随意访问。参见安全方法。浏览器直接发出的GET只能由一个url触发。GET上要在url之外带一些参数就只能依靠url上附带querystring。 POST 向指定资源提交数据，请求服务器进行处理（例如提交表单或者上传文件）。数据被包含在请求本文中。这个请求可能会创建新的资源或修改现有资源，或二者皆有。每次提交，表单的数据被浏览器用编码到HTTP请求的body里。浏览器发出的POST请求的body主要有两种格式，一种是application/x-www-form-urlencoded用来传输简单的数据，大概就是”key1=value1&amp;key2=value2”这样的格式。另外一种是传文件，会采用multipart/form-data格式。采用后者是因为application/x-www-form-urlencoded的编码方式对于文件这种二进制的数据非常低效。 PUT 向指定资源位置上传其最新内容。 DELETE 请求服务器删除Request-URI所标识的资源。 HEAD 与GET方法一样，都是向服务器发出指定资源的请求。只不过服务器将不传回资源的本文部分。它的好处在于，使用这个方法可以在不必传输全部内容的情况下，就可以获取其中“关于该资源的信息”（元信息或称元数据）。 TRACE 回显服务器收到的请求，主要用于测试或诊断。 OPTIONS 这个方法可使服务器传回该资源所支持的所有HTTP请求方法。用’*’来代替资源名称，向Web服务器发送OPTIONS请求，可以测试服务器功能是否正常运作。 CONNECT 方法名称是区分大小写的。当某个请求所针对的资源不支持对应的请求方法的时候，服务器应当返回状态码405（Method Not Allowed），当服务器不认识或者不支持对应的请求方法的时候，应当返回状态码501（Not Implemented）。 HTTP服务器至少应该实现GET和HEAD方法，其他方法都是可选的。当然，所有的方法支持的实现都应当符合下述的方法各自的语义定义。此外，除了上述方法，特定的HTTP服务器还能够扩展自定义的方法。例如： PATCH（由 RFC 5789指定的方法） 用于将局部修改应用到资源。 请求头请求头从第二行开始，到第一个空行结束。请求头和请求体之间存在一个空行。 请求头通常以键值对{key:value}方式传递数据。 key为规范的固定值。value为key对应的取值，通常是一个值，可能是一组。 常见请求头属性 Referer:表示这个请求是从哪个url跳过来的,通过百度来搜索淘宝网,那么在进入淘宝网的请求报文中,Referer的值就是:www.baidu.com。如果是直接访问就不会有这个头。 Accept:告诉服务端,该请求所能支持的响应媒体类型(MIME type) User-Agent:浏览器通知服务器，客户端浏览器与操作系统相关信息 Connection:表示客户端与服务连接类型；Keep-Alive表示持久连接，close已关闭 Host:请求的服务器主机名 Content-Length:请求体的长度 Content-Type:用于指示所述媒体类型(MIME type)的资源。在请求中，客户端通知服务器实际发送了什么类型的数据。在响应中，告诉客户实际返回的内容的内容类型。 Cache-Control：指定请求和响应遵循的缓存机制 请求体空行下面的数据 HTTP版本HTTP/0.9 已过时。只接受GET一种请求方法，没有在通讯中指定版本号，且不支持请求头。由于该版本不支持POST方法，因此客户端无法向服务器传递太多信息。 HTTP/1.0 这是第一个在通讯中指定版本号的HTTP协议版本。 HTTP/1.1（[RFC 2616][https://cloud.tencent.com/developer/section/1190064]） 默认采用持续连接（Connection: keep-alive），能很好地配合代理服务器工作。还支持以管道方式在同时发送多个请求，以便降低线路负载，提高传输速度。 HTTP/1.1相较于HTTP/1.0协议的区别主要体现在： 缓存处理 带宽优化及网络连接的使用 错误通知的管理 消息在网络中的发送 互联网地址的维护 安全性及完整性 HTTP/2.0 ![image-20210223200751992](/Users/mac/Library/Application Support/typora-user-images/image-20210223200751992.png) ![image-20210223200825838](/Users/mac/Library/Application Support/typora-user-images/image-20210223200825838.png) HTTPS","categories":[],"tags":[]},{"title":"数据库与ORM","slug":"laravel源码-数据库和ORM","date":"2020-09-18T05:39:35.721Z","updated":"2021-03-16T04:56:38.676Z","comments":true,"path":"2020/09/18/laravel源码-数据库和ORM/","link":"","permalink":"http://leckkk.github.io/2020/09/18/laravel%E6%BA%90%E7%A0%81-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8CORM/","excerpt":"","text":"Database核心架构Laravel主要有两种方式与数据库进行交互： DB , DB是与 PHP 底层的 PDO 直接进行交互的，通过查询构建器提供了一个方便的接口来创建及运行数据库查询语句。 Eloquent Model, Eloquent 是建立在 DB 的查询构建器基础之上，对数据库进行了抽象的 ORM，功能十分丰富让我们可以避免写复杂的 SQL 语句，并用优雅的方式解决了数据表之间的关联关系。 上面说的这两个部分都包括在了 Illuminate/Database 包里面，除了作为 Laravel 的数据库层 Illuminate/Database还是一个 PHP 数据库工具集， 在任何项目里你都可以通过 composer install illuminate/databse 安装并使用它。 Database 服务注册与初始化Database是作为一种服务注册到服务容器里提供给Laravel应用使用的，他的服务提供容器是Iluminate\\Database\\DatabaseServiceProvider 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677//设置连接分析器和事件分发器public function boot()&#123; Model::setConnectionResolver($this-&gt;app[&#x27;db&#x27;]); Model::setEventDispatcher($this-&gt;app[&#x27;events&#x27;]);&#125;public function register()&#123; //清除掉已经 booted的Model和全局查询作用域 Model::clearBootedModels(); //注册ConnectionServices $this-&gt;registerConnectionServices(); //注册Eloquent工厂 $this-&gt;registerEloquentFactory(); $this-&gt;registerQueueableEntityResolver();&#125;public static function clearBootedModels()&#123; static::$booted = []; static::$globalScopes = [];&#125;protected function registerConnectionServices()&#123; // 连接工厂用于在数据库上创建实际的连接实例。我们将把工厂注入管理器，以便它可以在实际需要时（而不是以前）建立连接。（依赖注入使其能延迟加载） $this-&gt;app-&gt;singleton(&#x27;db.factory&#x27;, function ($app) &#123; return new ConnectionFactory($app); &#125;); // 数据库管理器用于解析各种连接，因为可以管理多个连接。它还实现了连接解析器接口，该接口可被其他需要连接的组件使用。 $this-&gt;app-&gt;singleton(&#x27;db&#x27;, function ($app) &#123; return new DatabaseManager($app, $app[&#x27;db.factory&#x27;]); &#125;); //数据库连接实例，是与底层PDO接口交互的底层类 $this-&gt;app-&gt;bind(&#x27;db.connection&#x27;, function ($app) &#123; return $app[&#x27;db&#x27;]-&gt;connection(); &#125;); //所以 DatabaseManager 作为接口与外部交互，在应用需要时通过 ConnectionFactory 创建了数据库连接实例，最后执行数据库的增删改查是由数据库连接实例来完成的。&#125;protected function registerEloquentFactory()&#123; $this-&gt;app-&gt;singleton(FakerGenerator::class, function ($app, $parameters) &#123; $locale = $parameters[&#x27;locale&#x27;] ?? $app[&#x27;config&#x27;]-&gt;get(&#x27;app.faker_locale&#x27;, &#x27;en_US&#x27;); if (! isset(static::$fakers[$locale])) &#123; static::$fakers[$locale] = FakerFactory::create($locale); &#125; static::$fakers[$locale]-&gt;unique(true); return static::$fakers[$locale]; &#125;); $this-&gt;app-&gt;singleton(EloquentFactory::class, function ($app) &#123; return EloquentFactory::construct( $app-&gt;make(FakerGenerator::class), $this-&gt;app-&gt;databasePath(&#x27;factories&#x27;) ); &#125;);&#125;//注册可排队实体解析器实现。protected function registerQueueableEntityResolver()&#123; $this-&gt;app-&gt;singleton(EntityResolver::class, function () &#123; return new QueueEntityResolver; &#125;);&#125; DatabaseManagerDatabaseManager是整个数据库服务的接口，我们通过DB门面进行操作时，实际上调用的就是DatabaseManager，它会通过数据库连接对象工厂（connectionFactory）获得数据库连接对象，然后数据库连接对象会进行具体的CURD操作。 比如我们在程序里执行了DB::table(&#39;user&#39;)-&gt;get()，在DatabaseManager中并没有table方法，这时就会触发__call()魔术函数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192class DatabaseManager implements ConnectionResolverInterface&#123; protected $app; protected $factory; protected $connections = []; public function __call($method, $parameters) &#123; return $this-&gt;connection()-&gt;$method(...$parameters); &#125; //没有指定connction是 name为空 connection就会获取到默认的mysql连接对象 public function connection($name = null) &#123; //解析连接名称 //在配置文件为默认情况下 $name 为空时 返回的值为 mysql 和 null list($database, $type) = $this-&gt;parseConnectionName($name); $name = $name ?: $database; //单例 if (! isset($this-&gt;connections[$name])) &#123; $this-&gt;connections[$name] = $this-&gt;configure( $this-&gt;makeConnection($database), $type ); &#125; return $this-&gt;connections[$name]; &#125; protected function parseConnectionName($name) &#123; $name = $name ?: $this-&gt;getDefaultConnection(); // 检查connection name 是否以::read, ::write结尾 比如&#x27;ucenter::read&#x27; return Str::endsWith($name, [&#x27;::read&#x27;, &#x27;::write&#x27;]) ? explode(&#x27;::&#x27;, $name, 2) : [$name, null]; &#125; public function getDefaultConnection() &#123; //获取默认连接名称 return $this-&gt;app[&#x27;config&#x27;][&#x27;database.default&#x27;]; &#125; protected function configure(Connection $connection, $type) &#123; $connection = $this-&gt;setPdoForType($connection, $type); //首先，我们将设置获取模式和数据库连接的其他一些依赖项。此方法基本上只是配置并准备使其被应用程序使用。完成后，我们将其退回。 if ($this-&gt;app-&gt;bound(&#x27;events&#x27;)) &#123; $connection-&gt;setEventDispatcher($this-&gt;app[&#x27;events&#x27;]); &#125; //在这里，我们将设置一个reconnector回调。此重新连接器可以是任何可调用的，因此我们将设置一个Closure以使用此连接的名称从此管理器重新连接，这将允许我们从连接重新连接。 $connection-&gt;setReconnector($this-&gt;reconnector); return $connection; &#125; protected function makeConnection($name) &#123; //$name是&#x27;mysql&#x27;情况下, 从config/database.php中获取&#x27;connections.mysql&#x27;的配置 $config = $this-&gt;configuration($name); //首先，我们将通过连接名称进行检查，以查看是否已专门为此连接注册了扩展。如果有，我们将调用Closure，并将其传递给配置以使其能够解析连接。 //比如在AppServiceProvider里通过DatabaseManager::extend(&#x27;mysql&#x27;, function () &#123;...&#125;) if (isset($this-&gt;extensions[$name])) &#123; return call_user_func($this-&gt;extensions[$name], $config, $name); &#125; //接下来，我们将检查是否已为驱动程序注册扩展名，如果已注册，则将调用Closure，这将使我们能够为驱动程序本身提供一个更通用的解析器，该解析器适用于所有连接。 if (isset($this-&gt;extensions[$driver = $config[&#x27;driver&#x27;]])) &#123; return call_user_func($this-&gt;extensions[$driver], $config, $name); &#125; //通过工厂获取连接实例 return $this-&gt;factory-&gt;make($config, $name); &#125; protected function configuration($name) &#123; $name = $name ?: $this-&gt;getDefaultConnection(); //要获取数据库连接配置，我们将仅提取连接配置并获取给定名称的配置。如果配置不存在，我们将抛出异常并保释。 $connections = $this-&gt;app[&#x27;config&#x27;][&#x27;database.connections&#x27;]; if (is_null($config = Arr::get($connections, $name))) &#123; throw new InvalidArgumentException(&quot;Database connection [&#123;$name&#125;] not configured.&quot;); &#125; return (new ConfigurationUrlParser) -&gt;parseConfiguration($config); &#125;&#125; makeConnection中调用了ConnectionFatory的make方法来获取连接对象 1234567891011121314151617181920212223242526272829303132333435363738public function make(array $config, $name = null)&#123; $config = $this-&gt;parseConfig($config, $name); //是否有设置读写分离 如果设置了读写分离，那么就会调用 createReadWriteConnection 函数，生成具有读、写两个功能的 connection；否则的话，就会调用 createSingleConnection 函数，生成普通的连接对象。 if (isset($config[&#x27;read&#x27;])) &#123; return $this-&gt;createReadWriteConnection($config); &#125; return $this-&gt;createSingleConnection($config);&#125;protected function parseConfig(array $config, $name)&#123; return Arr::add(Arr::add($config, &#x27;prefix&#x27;, &#x27;&#x27;), &#x27;name&#x27;, $name);&#125;//创建单个connectionprotected function createSingleConnection(array $config)&#123; $pdo = $this-&gt;createPdoResolver($config); return $this-&gt;createConnection( $config[&#x27;driver&#x27;], $pdo, $config[&#x27;database&#x27;], $config[&#x27;prefix&#x27;], $config );&#125;//创建读写两个connectionprotected function createReadWriteConnection(array $config)&#123; $connection = $this-&gt;createSingleConnection($this-&gt;getWriteConfig($config)); return $connection-&gt;setReadPdo($this-&gt;createReadPdo($config));&#125;//创建数据库连接的方法 createConnection 的 $pdo是一个闭包function () use ($config) &#123; return $this-&gt;createConnector($config)-&gt;connect($config);&#125;; Connector在illuminate/database中连接器Connector是专门负责与PDO交互连接数据库的。createConnector方法会创建连接器： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public function createConnector(array $config)&#123; if (! isset($config[&#x27;driver&#x27;])) &#123; throw new InvalidArgumentException(&#x27;A driver must be specified.&#x27;); &#125; if ($this-&gt;container-&gt;bound($key = &quot;db.connector.&#123;$config[&#x27;driver&#x27;]&#125;&quot;)) &#123; return $this-&gt;container-&gt;make($key); &#125; switch ($config[&#x27;driver&#x27;]) &#123; case &#x27;mysql&#x27;: return new MySqlConnector; case &#x27;pgsql&#x27;: return new PostgresConnector; case &#x27;sqlite&#x27;: return new SQLiteConnector; case &#x27;sqlsrv&#x27;: return new SqlServerConnector; &#125; throw new InvalidArgumentException(&quot;Unsupported driver [&#123;$config[&#x27;driver&#x27;]&#125;]&quot;);&#125;//mysql的连接器class MySqlConnector extends Connector implements ConnectorInterface &#123; public function connect(array $config) &#123; //生成PDO连接数据库时用的DSN连接字符串 $dsn = $this-&gt;getDsn($config); //获取要传给PDO的选项参数 $options = $this-&gt;getOptions($config); //创建一个PDO连接对象 $connection = $this-&gt;createConnection($dsn, $config, $options); if (! empty($config[&#x27;database&#x27;])) &#123; $connection-&gt;exec(&quot;use `&#123;$config[&#x27;database&#x27;]&#125;`;&quot;); &#125; //为连接设置字符集和collation $this-&gt;configureEncoding($connection, $config); //设置time zone $this-&gt;configureTimezone($connection, $config); //为数据库会话设置sql mode $this-&gt;setModes($connection, $config); return $connection; &#125;&#125; 这样就通过连接器与 PHP 底层的 PDO 交互连接上数据库了。 Connection 就是 DatabaseManager 代理的数据库连接对象了， 所以最开始执行的代码 DB::table(&#39;users&#39;)-&gt;get() 经过我们上面讲的历程，最终是由 Connection 来完成执行的，table 方法返回了一个 QueryBuilder 对象，这个对象里定义里那些我们经常用到的 where, get,first 等方法， 它会根据调用的方法生成对应的 SQL 语句，最后通过 Connection 对象执行来获得最终的结果。 详细内容我们等到以后讲查询构建器的时候再看。 总结 名称 作用 DB DatabaseManager的静态代理。 DatabaseManager Database面向外部的接口，应用中所有与Database有关的操作都是通过与这个接口交互来完成的。 ConnectionFactory 创建数据库连接对象的类工厂。 Connection 数据库连接对象，执行数据库操作最后都是通过它与PHP底层的PDO交互来完成的。 Connector 作为Connection的成员专门负责过PDO连接数据库 查询构造器","categories":[],"tags":[]},{"title":"PHP相关","slug":"PHP 拓展安装","date":"2020-07-21T11:41:27.856Z","updated":"2021-03-16T04:58:00.918Z","comments":true,"path":"2020/07/21/PHP 拓展安装/","link":"","permalink":"http://leckkk.github.io/2020/07/21/PHP%20%E6%8B%93%E5%B1%95%E5%AE%89%E8%A3%85/","excerpt":"","text":"1.查看当前已经安装的拓展1php -m 这个命令会打印出你现在已经安装的拓展 2.下载对应版本的php安装包1wget -O php-7.3.12.tar.gz http://cn2.php.net/get/php-7.3.12.tar.gz/from/this/mirror 3.解压php的压缩包1tar -zxvf php-7.3.12.tar.gz ~ 4.进入拓展目录1～/php-7.3.12/ext/fileinfo 这里我解压到了～目录 所以是～/ 拓展包放置的文件夹是ext文件夹 进入你所需要安装的拓展的包 我这里进的是fileinfo 5.编译并安装123456789#我php安装在/usr/local/php中#这两行命令都要在 ～/php-7.3.12/ext/fileinfo 中执行/usr/local/php/bin/pipize./configure -with-php-config=/usr/local/php/bin/php-configmake &amp;&amp; make install 6.修改php.ini我这添加了fileinfo拓展 所以就 加入 extension=fileinfo 代码测试覆盖率 phpunit –coverage-html ./your_document tests/your_test_file","categories":[],"tags":[]},{"title":"自动加载解析","slug":"laravel源码-自动加载解析","date":"2020-07-21T11:32:38.232Z","updated":"2021-03-16T04:57:11.392Z","comments":true,"path":"2020/07/21/laravel源码-自动加载解析/","link":"","permalink":"http://leckkk.github.io/2020/07/21/laravel%E6%BA%90%E7%A0%81-%E8%87%AA%E5%8A%A8%E5%8A%A0%E8%BD%BD%E8%A7%A3%E6%9E%90/","excerpt":"","text":"Laravel 框架启动的第一件事便是加载 自动加载文件 1require __DIR__.&#x27;/../vendor/autoload.php&#x27;; 而这个autoload.php中却只有简简单单的几行代码 123require_once __DIR__ . &#x27;/composer/autoload_real.php&#x27;;return ComposerAutoloaderInitba18d171b895589f003c9e6898eda4c0::getLoader(); 而这个autoload_real.php 才是真正的核心代码 整个autoload_real.php源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566class ComposerAutoloaderInitba18d171b895589f003c9e6898eda4c0&#123; private static $loader; public static function loadClassLoader($class) &#123; if (&#x27;Composer\\Autoload\\ClassLoader&#x27; === $class) &#123; require __DIR__ . &#x27;/ClassLoader.php&#x27;; &#125; &#125; public static function getLoader() &#123; if (null !== self::$loader) &#123; return self::$loader; &#125; spl_autoload_register(array(&#x27;ComposerAutoloaderInitba18d171b895589f003c9e6898eda4c0&#x27;, &#x27;loadClassLoader&#x27;), true, true); self::$loader = $loader = new \\Composer\\Autoload\\ClassLoader(); spl_autoload_unregister(array(&#x27;ComposerAutoloaderInitba18d171b895589f003c9e6898eda4c0&#x27;, &#x27;loadClassLoader&#x27;)); $useStaticLoader = PHP_VERSION_ID &gt;= 50600 &amp;&amp; !defined(&#x27;HHVM_VERSION&#x27;) &amp;&amp; (!function_exists(&#x27;zend_loader_file_encoded&#x27;) || !zend_loader_file_encoded()); if ($useStaticLoader) &#123; require_once __DIR__ . &#x27;/autoload_static.php&#x27;; call_user_func(\\Composer\\Autoload\\ComposerStaticInitba18d171b895589f003c9e6898eda4c0::getInitializer($loader)); &#125; else &#123; $map = require __DIR__ . &#x27;/autoload_namespaces.php&#x27;; foreach ($map as $namespace =&gt; $path) &#123; $loader-&gt;set($namespace, $path); &#125; $map = require __DIR__ . &#x27;/autoload_psr4.php&#x27;; foreach ($map as $namespace =&gt; $path) &#123; $loader-&gt;setPsr4($namespace, $path); &#125; $classMap = require __DIR__ . &#x27;/autoload_classmap.php&#x27;; if ($classMap) &#123; $loader-&gt;addClassMap($classMap); &#125; &#125; $loader-&gt;register(true); if ($useStaticLoader) &#123; $includeFiles = Composer\\Autoload\\ComposerStaticInitba18d171b895589f003c9e6898eda4c0::$files; &#125; else &#123; $includeFiles = require __DIR__ . &#x27;/autoload_files.php&#x27;; &#125; foreach ($includeFiles as $fileIdentifier =&gt; $file) &#123; composerRequireba18d171b895589f003c9e6898eda4c0($fileIdentifier, $file); &#125; return $loader; &#125;&#125;function composerRequireba18d171b895589f003c9e6898eda4c0($fileIdentifier, $file)&#123; if (empty($GLOBALS[&#x27;__composer_autoload_files&#x27;][$fileIdentifier])) &#123; require $file; $GLOBALS[&#x27;__composer_autoload_files&#x27;][$fileIdentifier] = true; &#125;&#125; 我们一块一块来讲 第一块 单例和实例化1234567891011121314151617181920class ComposerAutoloaderInitba18d171b895589f003c9e6898eda4c0&#123; public static function loadClassLoader($class) &#123; if (&#x27;Composer\\Autoload\\ClassLoader&#x27; === $class) &#123; require __DIR__ . &#x27;/ClassLoader.php&#x27;; &#125; &#125; public static function getLoader() &#123; if (null !== self::$loader) &#123; return self::$loader; &#125; spl_autoload_register(array(&#x27;ComposerAutoloaderInitba18d171b895589f003c9e6898eda4c0&#x27;, &#x27;loadClassLoader&#x27;), true, true); self::$loader = $loader = new \\Composer\\Autoload\\ClassLoader(); spl_autoload_unregister(array(&#x27;ComposerAutoloaderInitba18d171b895589f003c9e6898eda4c0&#x27;, &#x27;loadClassLoader&#x27;)); &#125;&#125; 这里的类名 ComposerAutoloaderInitba18d171b895589f003c9e6898eda4c0 是ComposerAutoloaderInit + 一串hash字符串拼接成的 目的就是防止你会用到相同的类名 往下看就是 getLoader() 方法中的前3行 很明显他是一个单例 然后就是 spl_autoload_register(array(‘ComposerAutoloaderInitba18d171b895589f003c9e6898eda4c0’, ‘loadClassLoader’), true, true); self::$loader = $loader = new \\Composer\\Autoload\\ClassLoader(); spl_autoload_unregister(array(‘ComposerAutoloaderInitba18d171b895589f003c9e6898eda4c0’, ‘loadClassLoader’)); 这里先是注册了 loadClassLoader 然后在实例化ClassLoader()类之后 便又销毁了loadClassLoader 为什么不直接require，而要这么麻烦？原因就是怕有的用户也定义了个 \\Composer\\Autoload\\ClassLoader 命名空间，导致自动加载错误文件。那为什么不跟引导类一样用个 hash 呢？因为这个类是可以复用的，框架允许用户使用这个类。 第二块 初始化核心类123456789101112131415161718192021$useStaticLoader = PHP_VERSION_ID &gt;= 50600 &amp;&amp; !defined(&#x27;HHVM_VERSION&#x27;) &amp;&amp; (!function_exists(&#x27;zend_loader_file_encoded&#x27;) || !zend_loader_file_encoded()); if ($useStaticLoader) &#123; require_once __DIR__ . &#x27;/autoload_static.php&#x27;; call_user_func(\\Composer\\Autoload\\ComposerStaticInit6249d251c63e829a93df1039e481c2f3::getInitializer($loader)); &#125; else &#123; $map = require __DIR__ . &#x27;/autoload_namespaces.php&#x27;; foreach ($map as $namespace =&gt; $path) &#123; $loader-&gt;set($namespace, $path); &#125; $map = require __DIR__ . &#x27;/autoload_psr4.php&#x27;; foreach ($map as $namespace =&gt; $path) &#123; $loader-&gt;setPsr4($namespace, $path); &#125; $classMap = require __DIR__ . &#x27;/autoload_classmap.php&#x27;; if ($classMap) &#123; $loader-&gt;addClassMap($classMap); &#125; &#125; 这里先是判断 php的版本是否大于5.6 并且 没有使用HHVM 并且 没有zend_loader_file_encoded() 决定是否使用静态加载 若是 则使用getInitializer()直接加载 autoload_static.php 里面主要有 $files 全局函数 $prefixLengthsPsr4 PSR4标准顶级命名空间映射数组 这个里面放的是顶级命名空间的长度 $prefixDirsPsr4 根据长度再在这个数组中找到路径 $prefixesPsr0 psr0 规范的顶级命名空间映射 $classMap 直接命名空间全名与目录的映射，没有顶级命名空间 很庞大的一个数组 这五个数组 而getInitializer()绑定了后面四个数组 若不使用静态加载 其实也是将一个个命名空间映射与loader进行绑定 第三块 注册这块非常简单粗暴 123456$loader-&gt;register(true);public function register($prepend = false) &#123; spl_autoload_register(array($this, &#x27;loadClass&#x27;), true, $prepend); &#125; 就是将loadCLass注册到 PHP SPL的spl_autoload_register() 中去 每当PHP遇到一个不认识的命名空间的时候，PHP会自动调用注册到spl_autoload_register里面的函数堆栈，运行其中的每个函数，直到找到命名空间对应的文件。 然后就是加载 全局函数 12345678910if ($useStaticLoader) &#123; $includeFiles = Composer\\Autoload\\ComposerStaticInitba18d171b895589f003c9e6898eda4c0::$files;&#125; else &#123; $includeFiles = require __DIR__ . &#x27;/autoload_files.php&#x27;;&#125;foreach ($includeFiles as $fileIdentifier =&gt; $file) &#123; composerRequireba18d171b895589f003c9e6898eda4c0($fileIdentifier, $file);&#125;return $loader; 这里也区分是否使用静态加载 第四块 运行这块就是自动加载核心的核心了 12345678public function loadClass($class)&#123; if ($file = $this-&gt;findFile($class)) &#123; includeFile($file); return true; &#125;&#125; 这个就是被注册进spl_autoload_register() 的方法 奥秘就在findFile()这个方法里 12345678910111213141516171819202122232425262728293031323334public function findFile($class)&#123; // class map lookup if (isset($this-&gt;classMap[$class])) &#123; return $this-&gt;classMap[$class]; &#125; if ($this-&gt;classMapAuthoritative || isset($this-&gt;missingClasses[$class])) &#123; return false; &#125; if (null !== $this-&gt;apcuPrefix) &#123; $file = apcu_fetch($this-&gt;apcuPrefix.$class, $hit); if ($hit) &#123; return $file; &#125; &#125; $file = $this-&gt;findFileWithExtension($class, &#x27;.php&#x27;); // Search for Hack files if we are running on HHVM if (false === $file &amp;&amp; defined(&#x27;HHVM_VERSION&#x27;)) &#123; $file = $this-&gt;findFileWithExtension($class, &#x27;.hh&#x27;); &#125; if (null !== $this-&gt;apcuPrefix) &#123; apcu_add($this-&gt;apcuPrefix.$class, $file); &#125; if (false === $file) &#123; // Remember that this class does not exist. $this-&gt;missingClasses[$class] = true; &#125; return $file;&#125; 在PHP遇到不认识的命名空间的时候 便会执行findFile() 这里分两大块 classMap和findFileWithExtension()方法 classMap简单粗暴 就是从classMap数组中寻找 找到便返回 实际上大多数也都在第一个判断就被找到了 例如： 然后就是findFileWithExtension()了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879private function findFileWithExtension($class, $ext) &#123; // PSR-4 lookup // 将 ‘\\\\’ 转为 ‘/’ 并拼接上 .php //例如 ww\\\\ss\\\\cc =&gt; ww/ss/cc.php $logicalPathPsr4 = strtr($class, &#x27;\\\\&#x27;, DIRECTORY_SEPARATOR) . $ext; $first = $class[0]; //根据首字母来查找 if (isset($this-&gt;prefixLengthsPsr4[$first])) &#123; $subPath = $class; // 获取最右边的 \\\\ 并截取 例如：ww\\\\ss\\\\cc 变为 ww\\\\ss 循环在psr4标准中匹配 while (false !== $lastPos = strrpos($subPath, &#x27;\\\\&#x27;)) &#123; $subPath = substr($subPath, 0, $lastPos); $search = $subPath . &#x27;\\\\&#x27;; // ww\\\\ss\\\\ // 进行匹配 if (isset($this-&gt;prefixDirsPsr4[$search])) &#123; //若匹配上了 这里就会截取到/cc.php $pathEnd = DIRECTORY_SEPARATOR . substr($logicalPathPsr4, $lastPos + 1); // 对匹配上的psr4 数组遍历 检查是否有这个文件 若有就返回 foreach ($this-&gt;prefixDirsPsr4[$search] as $dir) &#123; if (file_exists($file = $dir . $pathEnd)) &#123; return $file; &#125; &#125; &#125; &#125; &#125; // PSR-4 fallback dirs foreach ($this-&gt;fallbackDirsPsr4 as $dir) &#123; if (file_exists($file = $dir . DIRECTORY_SEPARATOR . $logicalPathPsr4)) &#123; return $file; &#125; &#125; // PSR-0 lookup // ww\\\\ss\\\\cc =&gt; ww/ss if (false !== $pos = strrpos($class, &#x27;\\\\&#x27;)) &#123; // namespaced class name // 将路径最后的 _ 替换为 / $logicalPathPsr0 = substr($logicalPathPsr4, 0, $pos + 1) . strtr(substr($logicalPathPsr4, $pos + 1), &#x27;_&#x27;, DIRECTORY_SEPARATOR); &#125; else &#123; // PEAR-like class name // 替换路径里所有的 _ $logicalPathPsr0 = strtr($class, &#x27;_&#x27;, DIRECTORY_SEPARATOR) . $ext; &#125; // 根据路径首字母来查找 if (isset($this-&gt;prefixesPsr0[$first])) &#123; foreach ($this-&gt;prefixesPsr0[$first] as $prefix =&gt; $dirs) &#123; // 确认 class 中 有 prefix 并在 第0位 if (0 === strpos($class, $prefix)) &#123; // 遍历dirs数组 能找到文件就返回 foreach ($dirs as $dir) &#123; if (file_exists($file = $dir . DIRECTORY_SEPARATOR . $logicalPathPsr0)) &#123; return $file; &#125; &#125; &#125; &#125; &#125; // PSR-0 fallback dirs foreach ($this-&gt;fallbackDirsPsr0 as $dir) &#123; if (file_exists($file = $dir . DIRECTORY_SEPARATOR . $logicalPathPsr0)) &#123; return $file; &#125; &#125; // PSR-0 include paths. // 在当前include目录 查找 if ($this-&gt;useIncludePath &amp;&amp; $file = stream_resolve_include_path($logicalPathPsr0)) &#123; return $file; &#125; return false; &#125; 这里也分为两块 先在psr4规范中寻找 再在psr0规范中寻找 以上这些就是自动加载的原理了 参考文献：composer自动加载","categories":[],"tags":[]},{"title":"Linux Tip","slug":"Linux Tip","date":"2020-07-21T11:28:39.716Z","updated":"2021-03-16T04:57:34.416Z","comments":true,"path":"2020/07/21/Linux Tip/","link":"","permalink":"http://leckkk.github.io/2020/07/21/Linux%20Tip/","excerpt":"","text":"添加密钥添加ssh-key 实现免密登陆修改 /root/.ssh/authorized_keys直接在文件中复制入新的 ssh-key mv 命令移动整个目录 包括隐藏文件 使用.[!.]* 而不直接使用* 使用 * 会落下隐藏文件 firewall 常用命令查看防火墙服务的状态 systemctl status firewalld 查看防火墙状态 firewall-cmd –state 防火墙启动 关闭 重启 service firewalld start service firewalld restart service firewalld stop 查看防火墙规则列表 firewall-cmd –list-all 查询端口是否开放 firewall-cmd –query-port=8080/tcp 开放某端口 firewall-cmd –permanent –add-port=80/tcp 关闭某端口 firewall-cmd –permanent –remove-port=80/tcp 重启防火墙 （重新加载配置） firewall-cmd –reload ufw查看状态 ufw status 开启关闭防火墙 ufw enable ufw disable 开放关闭端口 ufw deny 53 ufw allow 53 并发测试工具安装 yum install httpd-tools 使用 ab -n 1000 -c 100 http://www.baidu.com/ -n 总请求数 -c 并发数 -k 是否开启长链接 ipv6 虚拟网卡命令1234567891011modprobe ipv6ip tunnel add he-ipv6 mode sit remote 66.220.18.42 local 106.14.126.63 ttl 255ip link set he-ipv6 upip addr add 2001:470:c:ece::2/64 dev he-ipv6ip route add ::/0 dev he-ipv6ip -f inet6 addr crontab www用户执行原因： laravel 的command命令由crontab执行 导致log文件的所有者为root用户 正常运行是为www用户 无法写入日志 导致大量报错 解决方法：选定执行用户 执行crontab 任务 修改 /etc/corntab 文件即可 在该文件中写的任务可以指定执行用户 superbench wget -qO- –no-check-certificate https://raw.githubusercontent.com/oooldking/script/master/superbench.sh | bash npsnps安装后的文件目录： /etc/nps nps可视化页面： IP:8080 连接客户端连接服务端命令： ./npc -server=106.14.126.63:8024 -vkey=wox6skcyhax3vwil -type=tcp","categories":[],"tags":[]},{"title":"nginx配置","slug":"nginx","date":"2020-07-21T11:25:06.420Z","updated":"2021-03-16T04:57:48.969Z","comments":true,"path":"2020/07/21/nginx/","link":"","permalink":"http://leckkk.github.io/2020/07/21/nginx/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748server &#123; listen 80;//ssl start listen 443 ssl http2; ssl_certificate /data/server/ssl/class-assistant-help.chingshen.co/class-assistant-help.chingshen.co.pem; ssl_certificate_key /data/server/ssl/class-assistant-help.chingshen.co/class-assistant-help.chingshen.co.key; ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; //ssl end server_name yuetu.api.chingshen.cn; access_log /data/wwwlogs/yuetu.api.chingshen.cn_nginx.log combined; index index.html index.htm index.php; root /data/wwwroot/yuetu.api.chingshen.cn/public;//ssl if ($ssl_protocol = &quot;&quot;) &#123; return 301 https://$host$request_uri; &#125;//ssl end//laravel try_file配置 要么直接写进文档 要么include进来 include /usr/local/nginx/conf/rewrite/laravel.conf;//laravel try_file #error_page 404 /404.html; #error_page 502 /502.html;//前端vue history location / &#123; try_files $uri $uri/ /index.html; &#125;//vue history end location ~ [^/]\\.php(/|$) &#123; #fastcgi_pass remote_php_ip:9000; fastcgi_pass unix:/dev/shm/php-cgi.sock; fastcgi_index index.php; include fastcgi.conf; &#125; location ~ .*\\.(gif|jpg|jpeg|png|bmp|swf|flv|mp4|ico)$ &#123; expires 30d; access_log off; &#125; location ~ .*\\.(js|css)?$ &#123; expires 7d; access_log off; &#125; location ~ /\\.ht &#123; deny all; &#125;&#125; 12345重写配置 rewrite/larval.conflocation / &#123; try_files $uri $uri/ /index.php?$query_string;&#125; 重新加载nginx配置1nginx -s reload","categories":[],"tags":[]},{"title":"laradock","slug":"laradock","date":"2020-07-21T11:21:20.830Z","updated":"2021-03-16T04:56:27.298Z","comments":true,"path":"2020/07/21/laradock/","link":"","permalink":"http://leckkk.github.io/2020/07/21/laradock/","excerpt":"","text":"启动容器docker-compose up -d nginx mysql redis 进入workspacedocker-compose exec workspace bash 坑#1workspace中的项目链接数据库时拒绝链接或者没有找到文件 应该吧项目的 HOST修改为使用的工具名 例如： DB_HOST=127.0.0.1 应改为：DB_HOST=mysql redis_host也是如此 #2最近在本地要跑多个项目 并且涉及到一个本地项目使用laravel的Http工具（curl）来请求本地的另一个项目，这时laradock就出现了点问题，给我报了 [curl] 7: Failed to connect to your-domain.test port 80: Connection refused 然后在宿主机的环境下用tinker工具请求 没问题 在laradock_workspace_1容器中进行curl请求，报错了 于是就定位问题出在容器（虽然不是workspace容器的问题） 搜索一番 尝试过在容器中修改hosts文件 将域名ip改为 10.0.75.2 的确有效，在容器中curl变了，变成了空返回报错 无效 最后搜索发现是nginx容器的问题 解决办法是修改docker-compose.yml文件 1234567networks: frontend: aliases: - your domain backend: aliases: - your domain 然后重新安装nginx docker-compose stop nginx docker-compose bild –no-cache nginx docker-compose up -d nginx 参考文献： github issue segment fault #3修改laradock的mysql的my.cnf重启容器不会生效 需要重新build #4使用php-fpm/xdebug stop关闭php-fpm容器的xdebug失败问题 原因：php-fpm/xdebug脚本中的xdebug_start和xdebug_stop函数中的 /usr/local/etc/php/conf.d/docker-php-ext-xdebug.ini 路径变为了/usr/local/etc/php/conf.d/xdebug.ini 导致 sed -i 的替换文本 替换失败 ‘s/^;zend_extension=/zend_extension=/g’ xdebug_start的替换文字 主要就是前面的注释符号","categories":[],"tags":[]}],"categories":[],"tags":[]}